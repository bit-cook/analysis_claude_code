# v8: チームメイト機構

**コアの洞察: サブエージェントは派遣された作業員、チームメイトは隣に座る同僚。**

v3のサブエージェントは「分割統治」: タスクを与え、実行し、結果を返して消滅。

```
v3 サブエージェント:
  メインエージェント -> "コードベースを探索して" -> サブエージェント
  メインエージェント <- "authはsrc/auth/にある" <- サブエージェント
  （サブエージェント消滅、コンテキスト破棄）
```

「フロントエンドとバックエンドを同時に開発する」ようなタスクでは不十分: 互いに通信できない、進捗を共有できない、実行が終われば消滅する。チームメイトが解決するのは**持続的な協力**の問題。

## サブエージェント vs チームメイト

| 特徴 | サブエージェント (v3) | チームメイト (v8) |
|------|---------------------|-------------------|
| ライフサイクル | 一回限り | 持続的（稼働 <-> 待機） |
| 通信 | 戻り値（単方向） | メッセージプロトコル（双方向） |
| 並列性 | 疑似並列（返却待ち） | 真の並列（独立スレッド） |
| タスク管理 | なし | 共有Tasks (v6) |
| 適用場面 | 一回限りのタスク | 複数モジュールの長期協力 |

## アーキテクチャ

```
Team Lead（メインエージェント）
  ├── Teammate: frontend   （デーモンスレッド）
  ├── Teammate: backend    （デーモンスレッド）
  └── 共有:
        ├── .tasks/         <- 全員が同じボードを見る
        └── .teams/         <- 各TeammateのJSONL受信箱
```

各Teammateはデーモンスレッドとして動作し、独自のエージェントループとコンテキストウィンドウを持ち、独立して圧縮（v5）を実行する。

## JSONL受信箱のファイル形式

各Teammateは `.teams/{team_name}/{name}_inbox.jsonl` に専用の受信箱ファイルを持つ。メッセージはJSON形式で1行に1つずつ格納:

```json
{"type": "message", "sender": "lead", "content": "まずログインページを完成させてください", "timestamp": 1709234567.89}
{"type": "broadcast", "sender": "backend", "content": "APIスキーマが確定した", "timestamp": 1709234590.12}
```

受信箱の読み取りは全メッセージを消費しファイルをクリアする（読み取り即クリアパターン）。重複処理を防ぎつつ、並行書き込みに対応したシンプルな追記形式を維持する。

## TEAMMATE_TOOLS vs ALL_TOOLS

TeammateとTeam Leadは異なるツールセットを受け取る:

| ツール | Team Lead | Teammate |
|--------|-----------|----------|
| bash, read_file, write_file, edit_file | あり | あり |
| TaskCreate, TaskUpdate, TaskList | あり | あり |
| TaskGet | あり | なし |
| SendMessage | あり | あり |
| Task（サブエージェント/Teammateの生成） | あり | なし |
| Skill | あり | なし |
| TaskOutput, TaskStop | あり | なし |
| TeamCreate, TeamDelete | あり | なし |

Teammateは `BASE_TOOLS + タスクCRUD + SendMessage` を受け取る。作業の実行、共有ボードの更新、仲間との通信には十分だが、他のエージェントの生成やチーム自体の管理はできない。これによりTeam Leadがオーケストレーターとしての役割を保つ。

## 3つのコアツール

```python
# TeamCreate: チームを作成
TeamCreate(name="my-project")

# SendMessage: Teammateにメッセージを送信
SendMessage(recipient="frontend", content="まずログインページを完成させてください")

# TeamDelete: チームを解散
TeamDelete(name="my-project")
```

TeammateはTaskツールで生成し、`team_name`を指定する:

```python
Task(prompt="フロントエンド開発を担当", team_name="my-project", name="frontend")
# -> 一回限りのサブエージェントではなく、持続的なTeammateを生成
```

## Teammateの状態マシン

Teammateのライフサイクルは継続的な `active -> idle -> active` サイクル:

```
                    +---> active（エージェントループ実行、ツール使用）
                    |         |
                    |         v
   spawn -----> active   idle（2秒ごとに受信箱をポーリング、60秒間）
                              |
                    +---------+-- 新メッセージ到着 -> active
                    |         +-- 未割当タスク発見 -> active
                    |         +-- shutdown_request -> 終了
                    |         +-- 60秒タイムアウト -> idleループ継続
                    |
                    +--- (次のサイクルでidleに戻る)
```

**active**フェーズでは、Teammateは通常のエージェントループ（API呼び出し -> ツール使用 -> API呼び出し）を実行する。モデルがツール呼び出しを停止（`stop_reason != "tool_use"`）すると、**idle**に遷移。

**idle**フェーズでは、Teammateは2秒ごとに最大60秒間受信箱をポーリング:
1. **新メッセージ**が到着したら、コンテキストに注入してactiveに戻る
2. タスクボードで**未割当タスク**（status=pending、ownerなし、blockerなし）を発見したら、`TaskUpdate(owner=name)` で自動割当してactiveに戻る
3. **shutdown_request**を受信したら、ループを完全に終了
4. 60秒間何も起きなければ、idleポーリングサイクルを再開

## ブロードキャストの仕組み

ブロードキャストは独立したメソッドではない。同じ `send_message()` 関数を `msg_type="broadcast"` で使用する:

```python
# コード内では、broadcastがチーム内の全Teammateを巡回
SendMessage(recipient="anyone", content="スキーマが確定した", type="broadcast", team_name="my-project")
```

内部では、マネージャーがチーム内の全Teammate（送信者を除く）を巡回し、各TeammateのJSONL受信箱ファイルにメッセージを追記する。ブロードキャストでは `recipient` フィールドは無視される -- メッセージは全員に送られる。

## タスク割当の仕組み

Teammateは共有タスクボードから自律的に作業を割り当てる:

```python
# idleフェーズ中、Teammateが未割当タスクをチェック
unclaimed = [t for t in TASK_MGR.list_all()
             if t.status == "pending" and not t.owner and not t.blocked_by]
if unclaimed:
    task = unclaimed[0]
    TASK_MGR.update(task.id, status="in_progress", owner=teammate.name)
```

割当は先着順（タスクIDでソート）。`TaskManager.update()` のスレッドロックが、複数のTeammateが同じタスクを同時に割当しようとした際の競合状態を防ぐ。

## シャットダウンプロトコル

シャットダウンはリクエスト-レスポンスプロトコル:

1. **Team Lead**が `SendMessage(type="shutdown_request")` でシャットダウン要求を送信
2. メッセージがTeammateのJSONL受信箱に書き込まれる
3. Teammateの次の**idleポーリング**で `shutdown_request` を読み取る
4. Teammateが `status = "shutdown"` を設定しループを終了（`return`）
5. スレッドはデーモンスレッドのため、joinは不要

`TeamDelete` はチーム内の全Teammateに同時に `shutdown_request` を送信し、その後レジストリからチームを削除する。

## コンテキスト圧縮時のアイデンティティ保持

Teammateのコンテキストが圧縮（v5 auto_compact）された場合、圧縮後のサマリーにはTeammateの身元が含まれない。Teammateループがアイデンティティを再注入する:

```python
if CTX.should_compact(sub_messages):
    sub_messages = CTX.auto_compact(sub_messages)
    identity = f"\n\nRemember: You are teammate '{teammate.name}' in team '{teammate.team_name}'."
    sub_messages[0]["content"] += identity
```

これにより、積極的なコンテキスト圧縮後でもモデルが自身の役割とチームのコンテキストを保持する。

## 完全な協力フロー

```
ユーザー: "アプリをRESTからGraphQLに移行して"

Team Lead:
  1. TeamCreate("rest-to-graphql")
  2. TaskCreate("Analyze REST endpoints")          -> #1
  3. TaskCreate("Design GraphQL schema")           -> #2, blockedBy=#1
  4. TaskCreate("Implement resolvers")             -> #3, blockedBy=#2
  5. TaskCreate("Update frontend")                 -> #4, blockedBy=#3

  6. Task(name="analyst", team_name=..., prompt="REST分析")
  7. Task(name="backend", team_name=..., prompt="バックエンド処理")
  8. Task(name="frontend", team_name=..., prompt="フロントエンド移行")

analyst:   #1 完了 -> idle
backend:   #2 解除 -> #2 完了 -> #3 完了 -> idle
frontend:  #4 解除 -> #4 完了 -> idle

Team Lead: 全員idle -> shutdown -> "移行完了。"
```

3つの仕組みが連動:
- **Tasks (v6)** は共有カンバンボード。全員が同じ進捗を見る
- **圧縮 (v5)** が各メンバーの長時間作業を可能にする
- **メッセージプロトコル** でメンバー間がいつでも通信できる

## 比較

| 側面 | v3 (サブエージェント) | v8 (チームメイト) |
|------|---------------------|-------------------|
| モデル | 一回限りの関数呼び出し | 持続的なワーカースレッド |
| 通信 | 戻り値 | メッセージプロトコル |
| 状態 | ステートレス | ステートフル（idle/active） |
| タスク管理 | なし | 共有Tasks |
| 並列性 | 疑似並列 | 真の並列 |

## より深い洞察

> **命令から協力へ。**

v3のサブエージェントはコマンドモデル: メインエージェントが命令し、サブエージェントが従う。v8のチームメイトは協力モデル: Team Leadが方向を割り当て、Teammateが自律的に作業し、互いに通信する。

```
サブエージェント -> 1つのことをして、報告に戻る（インターン）
チームメイト    -> 継続的に作業し、自律的にタスクを引き受ける（同僚）
Team Lead      -> タスクを分解し、進捗を管理し、計画を審査する（マネージャー）
```

エージェントシステムの究極形態は、より賢い単一モデルではなく、**協力できるモデルの集団**。

---

**1つのエージェントの能力には限界がある。エージェントの集団には限界がない。**

[<< v7](./v7-バックグラウンドタスク.md) | [READMEに戻る](../README_ja.md)
